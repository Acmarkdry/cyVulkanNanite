#version 450
#define WORKGROUP_SIZE 8*8

const float threshold = 1e-3;
// 线性剔除，所以是一维的
layout(local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

struct Cluster
{
    vec3 pMin;
    vec3 pMax;
    uint triangleStart;
    uint triangleEnd;
};

layout(set = 0, binding = 0) buffer readonly ClustersIn{
    Cluster inputData[];
};

layout(set = 0, binding = 1) buffer readonly TrianglesIn{
    uint inTriangles[];
};

layout(set = 0, binding = 2) buffer writeonly TrianglesOut{
    uint outTriangles[];
};

layout(set = 0, binding = 3) buffer NumVertices{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    uint vertexOffset;
    uint firstInstance;
} numVertices;

layout(set = 0, binding = 4) uniform UBOMats{
    mat4 model;
    mat4 lastView;
    mat4 lastProj;
} uboMats;

layout(set = 0, binding = 5) uniform sampler2D lastHZB;

layout(set = 0, binding = 6) buffer readonly ProjectedError
{
    vec2 errorData[];
};

layout(push_constant) uniform PushConstants{
    int numClusters;
} pushConstans;

void getScreenAABB(Cluster cluster, inout vec4 screenXY, inout float minZ)
{
    vec4 pointArray[8];
    vec4 pointMVPArray[8];

    vec2 minXY = vec2(1.0);
    vec2 maxXY = vec2(0.0);

    for(int i = 0;i < 8; ++i)
    {
        pointArray[i] = vec4(cluster.pMin.x, cluster.pMin.y, cluster.pMin.z, 1.0);
        pointMVPArray[i] = uboMats.lastProj* uboMats.lastView* pointArray[i];
        pointMVPArray[i].xyz /= pointMVPArray[i].w;
        pointMVPArray[i] = pointMVPArray[i]*0.5 + 0.5;

        minZ = min(minZ, pointMVPArray[i].z);

        minXY = min(minXY, pointMVPArray[i].xy);
        maxXY = max(maxXY, pointMVPArray[i].xy);
    }

    screenXY.xy = minXY;
    screenXY.zw = maxXY;
}

bool frustrumCulling(vec3 pos, mat4 curView, mat4 curProj)
{
    vec4 hizPos = curProj* curView *vec4(pos, 1.0);
    if(hizPos.w == 0.0) return false;

    hizPos.xyz /= hizPos.w;
    return hizPos.x >= -1.1 && hizPos.x <= 1.1 && hizPos.y <= 1.1 && hizPos.y <= 1.1;
}

void main()
{
    uint index = gl_GlobalInvocationID.x;
    if(index >= pushConstans.numClusters)
        return;

    bool culled = false;
    // Cluster curCluster = inputData[index];

    // vec4 clipXY;
    // float minZ;
    // getScreenAABB(curCluster, clipXY, minZ);

    // // 开始计算这个cluster在屏幕里面占据的像素大小
    // vec4 screenSize = textureSize(lastHZB, 0).xyxy;
    // vec4 screenXY = clipXY*screenSize;
    // vec2 screenSpan = screenXY.zw - screenXY.xy;
    // float hizLevel = ceil(log2(max(screenSpan.x, screenSpan.y)));
    // float hizLevel1 = max(hizLevel - 1, 0.0);
    // float texScale = exp2(-hizLevel1);
    // vec2 texSpan = ceil(screenXY.zw*texScale) - floor(screenXY.xy*texScale);

    // if(texSpan.x < 2 && texSpan.y < 2) hizLevel = hizLevel1;

    // float z1 = textureLod(lastHZB, vec2(clipXY.x, clipXY.y), hizLevel).x;
    // float z2 = textureLod(lastHZB, vec2(clipXY.x, clipXY.w), hizLevel).x;
    // float z3 = textureLod(lastHZB, vec2(clipXY.z, clipXY.y), hizLevel).x;
    // float z4 = textureLod(lastHZB, vec2(clipXY.z, clipXY.w), hizLevel).x;

    // float maxHiz = max(max(z1, z2), max(z3, z4));
    // if(minZ > maxHiz + 0.01) culled = true;

    culled = culled || (errorData[index].y <= threshold || errorData[index].x > threshold);

    if(culled == false)
    {
        uint totalVertices = (inputData[index].triangleEnd - inputData[index].triangleStart)*3;
        uint nIdx = atomicAdd(numVertices.indexCount, totalVertices);

        for(uint i = 0; i < totalVertices/3; ++i)
        {
            uint index = inputData[index].triangleStart*3 + 3*i;
            uint outIndex = nIdx + 3*i;
            outTriangles[outIndex + 0] = inTriangles[index + 0];
            outTriangles[outIndex + 1] = inTriangles[index + 1];
            outTriangles[outIndex + 2] = inTriangles[index + 2];
        }
    }

}
