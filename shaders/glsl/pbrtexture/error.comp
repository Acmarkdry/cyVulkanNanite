#version 450
#define WORKGROUP_SIZE 64

layout(local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

struct ErrorInfo
{
    vec4 centerRadius;
    vec4 centerParentRadius;
    vec2 errorWorld;
};

layout(std430, set = 0, binding = 0) buffer readonly WorldError
{
    ErrorInfo inputData[];
};

layout(std430, set = 0, binding = 1) buffer ClusterError
{
    vec2 outputData[];
};

layout(set = 0, binding = 2) uniform UBOMats
{
    mat4 view;
    mat4 proj;
    vec3 camUp;
    vec3 camRight;
}ubo;

layout(push_constant) uniform PushConstants
{
    int numClusters;
    vec2 screenSize;
}pcs;

float getScreenBoundRadius(vec3 center, float radius)
{
    vec4 c = ubo.proj*ubo.view*vec4(center,1);
    c.xy/=c.w;
    c.xy=c.xy*0.5+0.5;
    vec4 p0 = ubo.proj*ubo.view*vec4(radius*ubo.camUp+center,1);
    p0.xy/=p0.w;
    p0.xy=p0.xy*0.5+0.5;
    vec4 p1 = ubo.proj*ubo.view*vec4(radius*ubo.camRight+center,1);
    p1.xy/=p1.w;
    p1.xy=p1.xy*0.5+0.5;
    vec2 v0 = (p0.xy-c.xy)*pcs.screenSize;
    vec2 v1 = (p1.xy-c.xy)*pcs.screenSize;
    return max(dot(v0,v0),dot(v1,v1));
}

void main()
{
    uint index = gl_GlobalInvocationID.x;
    if(index >= pcs.numClusters) return;

    ErrorInfo error = inputData[index];
    vec3 center;
    float radius;

    center = error.centerRadius.xyz;
    radius = error.centerRadius.w;
    outputData[index].x = error.errorWorld.x * getScreenBoundRadius(center,radius) / (radius*radius);

    center = error.centerParentRadius.xyz;
    radius = error.centerParentRadius.w;
    outputData[index].y = error.errorWorld.y * getScreenBoundRadius(center,radius) / (radius*radius);
}